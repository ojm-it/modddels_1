import 'package:modddels_annotations/modddels.dart';
import 'package:flutter_test/flutter_test.dart';
import 'package:collection/collection.dart';
import 'package:modddels_annotations/src/testers/common.dart';
import 'package:modddels_annotations/src/testers/testers_utils.dart';
import 'package:modddels_annotations/src/testers/value_objects_testers/test_cases.dart';
import 'package:modddels_annotations/src/testers/value_objects_testers/value_objects_testers.dart';

/// This is the base class of all ValueObject testers.
///
/// For now, there are two testers :
/// - [ValueObjectTester] : the SUT is a [ValueObject]
/// - [NullableValueObjectTester] : the SUT is a [NullableValueObject]
abstract class BaseValueObjectTester<
    T extends Object?,
    F extends ValueFailure<T>,
    I extends InvalidValueObject<T, F>,
    V extends ValidValueObject<T>,
    E extends Modddel<I, V>> extends Tester {
  /// For [maxSutDescriptionLength], see [Tester.maxSutDescriptionLength].
  const BaseValueObjectTester({required int maxSutDescriptionLength})
      : super(maxSutDescriptionLength: maxSutDescriptionLength);

  /// This is the description of the [group] generated by the
  /// [makeIsSanitizedTestGroup] method.
  String get isSanitizedGroupDescription;

  /// This is the description of the [group] generated by the
  /// [makeIsNotSanitizedTestGroup] method.
  String get isNotSanitizedGroupDescription;

  /// This is the description of the [group] generated by the
  /// [makeIsValidTestGroup] method.
  String get isValidGroupDescription;

  /// This is the description of the [group] generated by the
  /// [makeIsInvalidTestGroup] method.
  String get isInvalidGroupDescription;

  /// The constructor of the subject under test (SUT).
  E Function(T input) get sutConstructor;

  /// The SUT should hold [sanitizedValue] when given [input].
  void expectIsSanitized({required T input, required T sanitizedValue}) {
    final valueObject = sutConstructor(input);
    final value = valueObject.mapValidity(
        valid: (valid) => valid.value,
        invalid: (invalid) => invalid.valueFailure.failedValue);
    expect(value, sanitizedValue);
  }

  /// The SUT should hold the same [input] that was given to it.
  void expectIsNotSanitized({required T input}) {
    final valueObject = sutConstructor(input);
    final value = valueObject.mapValidity(
        valid: (valid) => valid.value,
        invalid: (invalid) => invalid.valueFailure.failedValue);
    expect(value, input);
  }

  /// The SUT should be valid when given [input].
  void expectIsValid({required T input}) {
    final valueObject = sutConstructor(input);
    expect(valueObject, isA<V>());
    expect(valueObject.isValid, true);
  }

  /// The SUT should be invalid when given [input] and hold the [valueFailure].
  void expectIsInvalid({required T input, required F valueFailure}) {
    final valueObject = sutConstructor(input);
    expect(valueObject, isA<I>());
    expect(valueObject.isValid, false);
    expect((valueObject as I).valueFailure, valueFailure);
  }

  /// Generates a [group] that contains all the TestIsSanitized [tests].
  ///
  /// The [group]'s description is set to [isSanitizedGroupDescription], but you
  /// can override it by providing your own [description].
  ///
  /// If [maxSutDescriptionLength] is provided, then it overrides the value
  /// of this tester's [Tester.maxSutDescriptionLength].
  ///
  /// For documentation of [description] and [skip], see [group].
  void makeIsSanitizedTestGroup({
    required List<TestIsSanitized<T>> tests,
    int? maxSutDescriptionLength,
    Object? description,
    dynamic skip,
  }) {
    assert(maxSutDescriptionLength == null ||
        maxSutDescriptionLength > 0 ||
        maxSutDescriptionLength == TesterUtils.noEllipsis);

    group(
      description ?? isSanitizedGroupDescription,
      () {
        for (final _test in tests) {
          final input = _test.input;
          final sanitizedValue = _test.sanitizedValue;

          final maxLength =
              maxSutDescriptionLength ?? this.maxSutDescriptionLength;

          final description = '- "${TesterUtils.formatObject(
            input,
            maxLength: maxLength,
            maxLengthFactor: 0.5,
          )}" '
              'â†’ "${TesterUtils.formatObject(
            sanitizedValue,
            maxLength: maxLength,
            maxLengthFactor: 0.5,
          )}"';
          final finalDescription = _test.getFinalDescription(description);
          test(
            finalDescription,
            () {
              expectIsSanitized(input: input, sanitizedValue: sanitizedValue);
            },
            testOn: _test.testOn,
            timeout: _test.timeout,
            skip: _test.skip,
            tags: _test.tags,
            onPlatform: _test.onPlatform,
            retry: _test.retry,
          );
        }
      },
      skip: skip,
    );
  }

  /// Generates a [group] that contains all the TestIsNotSanitized [tests].
  ///
  /// The [group]'s description is set to [isNotSanitizedGroupDescription], but
  /// you can override it by providing your own [description].
  ///
  /// If [maxSutDescriptionLength] is provided, then it overrides the value
  /// of this tester's [Tester.maxSutDescriptionLength].
  ///
  /// For documentation of [description] and [skip], see [group].
  void makeIsNotSanitizedTestGroup({
    required List<TestIsNotSanitized<T>> tests,
    int? maxSutDescriptionLength,
    Object? description,
    dynamic skip,
  }) {
    assert(maxSutDescriptionLength == null ||
        maxSutDescriptionLength > 0 ||
        maxSutDescriptionLength == TesterUtils.noEllipsis);

    group(
      description ?? isNotSanitizedGroupDescription,
      () {
        for (final _test in tests) {
          final input = _test.input;

          final maxLength =
              maxSutDescriptionLength ?? this.maxSutDescriptionLength;

          final description = '- "${TesterUtils.formatObject(
            input,
            maxLength: maxLength,
          )}"';
          final finalDescription = _test.getFinalDescription(description);
          test(
            finalDescription,
            () {
              expectIsNotSanitized(input: input);
            },
            testOn: _test.testOn,
            timeout: _test.timeout,
            skip: _test.skip,
            tags: _test.tags,
            onPlatform: _test.onPlatform,
            retry: _test.retry,
          );
        }
      },
      skip: skip,
    );
  }

  /// Generates a [group] that contains all the TestIsValidValue [tests].
  ///
  /// The [group]'s description is set to [isValidGroupDescription], but you
  /// can override it by providing your own [description].
  ///
  /// If [maxSutDescriptionLength] is provided, then it overrides the value
  /// of this tester's [Tester.maxSutDescriptionLength].
  ///
  /// For documentation of [description] and [skip], see [group].
  void makeIsValidTestGroup({
    required List<TestIsValidValue<T>> tests,
    int? maxSutDescriptionLength,
    Object? description,
    dynamic skip,
  }) {
    assert(maxSutDescriptionLength == null ||
        maxSutDescriptionLength > 0 ||
        maxSutDescriptionLength == TesterUtils.noEllipsis);

    group(
      description ?? isValidGroupDescription,
      () {
        for (final _test in tests) {
          final input = _test.input;

          final maxLength =
              maxSutDescriptionLength ?? this.maxSutDescriptionLength;

          final description = '- "${TesterUtils.formatObject(
            input,
            maxLength: maxLength,
          )}"';
          final finalDescription = _test.getFinalDescription(description);
          test(
            finalDescription,
            () {
              expectIsValid(input: input);
            },
            testOn: _test.testOn,
            timeout: _test.timeout,
            skip: _test.skip,
            tags: _test.tags,
            onPlatform: _test.onPlatform,
            retry: _test.retry,
          );
        }
      },
      skip: skip,
    );
  }

  /// Generates a [group] that contains all the TestIsInvalidValue [tests]. The
  /// tests that concern the same [ValueFailure] union-case are grouped into the
  /// same subgroups.
  ///
  /// The [group]'s description is set to [isInvalidGroupDescription], but you
  /// can override it by providing your own [description]. Each subgroup's
  /// description is the formatted className of the [ValueFailure] union-case.
  ///
  /// If [maxSutDescriptionLength] is provided, then it overrides the value
  /// of this tester's [Tester.maxSutDescriptionLength].
  ///
  /// For documentation of [description] and [skip], see [group].
  void makeIsInvalidTestGroup({
    required List<TestIsInvalidValue<T, F>> tests,
    int? maxSutDescriptionLength,
    Object? description,
    dynamic skip,
  }) {
    assert(maxSutDescriptionLength == null ||
        maxSutDescriptionLength > 0 ||
        maxSutDescriptionLength == TesterUtils.noEllipsis);

    group(
      description ?? isInvalidGroupDescription,
      () {
        /// The keys are the [ValueFailure] union-cases classNames, and the
        /// values are the tests that concern each [ValueFailure] union-case.
        final testGroups = groupBy<TestIsInvalidValue<T, F>, String>(
          tests,
          (test) => TesterUtils.formatFailure(test.valueFailure),
        );

        testGroups.forEach((key, value) {
          group(
            '"$key"',
            () {
              for (final _test in value) {
                final input = _test.input;

                final maxLength =
                    maxSutDescriptionLength ?? this.maxSutDescriptionLength;

                final description = '- "${TesterUtils.formatObject(
                  input,
                  maxLength: maxLength,
                )}"';
                final finalDescription = _test.getFinalDescription(description);
                test(
                  finalDescription,
                  () {
                    expectIsInvalid(
                        input: input, valueFailure: _test.valueFailure);
                  },
                  testOn: _test.testOn,
                  timeout: _test.timeout,
                  skip: _test.skip,
                  tags: _test.tags,
                  onPlatform: _test.onPlatform,
                  retry: _test.retry,
                );
              }
            },
          );
        });
      },
      skip: skip,
    );
  }
}

import 'package:equatable/equatable.dart';
import 'package:modddels_annotations/src/modddels/entities/common.dart';
import 'package:modddels_annotations/src/modddels/entities/general_entity.dart';
import 'package:modddels_annotations/src/modddels/entities/simple_entity.dart';
import 'package:modddels_annotations/src/modddels/modddel.dart';
import 'package:modddels_annotations/src/modddels/value_objects/multi_value_object.dart';
import 'package:modddels_annotations/src/modddels/value_objects/single_value_object.dart';
import 'package:modddels_annotations/src/modddels/value_objects/value_object.dart';
import 'package:modddels_annotations/src/testers/core/testers_utils.dart';

enum StringifyMode {
  always,
  never,
  debugMode,
}

class ModddelAnnotation {
  const ModddelAnnotation({
    this.generateTester = true,
    this.maxSutDescriptionLength = 100,
    this.stringifyMode = StringifyMode.always,
  });

  /// Whether to generate a Tester for this Modddel.
  ///
  /// Defaults to `true`.
  final bool generateTester;

  /// The tests generated by the methods of the Tester have a description that
  /// usually contains the String representation of the SUT.
  ///
  /// This [maxSutDescriptionLength] is the maximum length of that String,
  /// beyond which it is ellipsized.
  ///
  /// Defaults to `100`.
  ///
  /// You can disable this "ellipsisation" by setting this
  /// [maxSutDescriptionLength] to [TesterUtils.noEllipsis].
  final int maxSutDescriptionLength;

  /// Dictates how [Equatable.stringify] method should be overridden for this
  /// modddel, and thus how the `toString` method will behave.
  ///
  /// - [StringifyMode.never] : The `toString` method won't include the props of
  ///   the modddel in neither Debug mode nor Release mode.
  ///
  ///   Behind the scenes, the [stringifyMode] method is overridden to return
  ///   `false`.
  ///
  /// - [StringifyMode.always] : The `toString` method will include the props of
  ///   the modddel in both Debug mode and Release mode.
  ///
  ///   Behind the scenes, the [stringifyMode] method is overridden to return
  ///   `true`.
  ///
  /// - [StringifyMode.debugMode] : The `toString` method will include the props
  ///   of the modddel in Debug mode, and won't include them in Release mode.
  ///
  ///   Behind the scenes, the [stringifyMode] method is overridden to return
  ///   `null`, which means it falls back to the value of
  ///   [EquatableConfig.stringify], which defaults to true in debug mode and
  ///   false in release mode.
  ///
  /// Defaults to [StringifyMode.always].
  final StringifyMode stringifyMode;
}

class ValidAnnotation {
  const ValidAnnotation();
}

class InvalidAnnotation {
  const InvalidAnnotation();
}

class WithGetterAnnotation {
  const WithGetterAnnotation();
}

class ValidWithGetterAnnotation {
  const ValidWithGetterAnnotation();
}

class InvalidWithGetterAnnotation {
  const InvalidWithGetterAnnotation();
}

const modddel = ModddelAnnotation();

/// This annotation can only be used inside a [SimpleEntity] or a
/// [GeneralEntity], in front of a factory parameter.
///
/// Use this annotation :
/// - When you want a [SimpleEntity] or a [GeneralEntity] to contain a modddel
///   that should be considered as being valid (so it shouldn't be validated)
/// - When a parameter isn't a modddel and should be considered as being valid.
///   For example : a [ValidValueObject], a [ValidEntity], a boolean...
///
/// Example :
///
/// ```dart
/// factory FullName({
///    required Name firstName,
///    required Name lastName,
///    @valid required bool hasMiddleName,
///  }) { ...
/// ```

const valid = ValidAnnotation();

/// This annotation can only be used inside a [SimpleEntity] or a
/// [GeneralEntity], in front of a **nullable** factory parameter.
///
/// Use this annotation when you want a [SimpleEntity] or a [GeneralEntity]
/// to contain an [InvalidModddel] that should be always considered as invalid,
/// unless it's null.
///
/// Example :
///
/// ```dart
/// factory FullName({
///    required Name firstName,
///    required Name lastName,
///    @invalid @TypeName('InvalidName?') required InvalidName? middleName,
///  }) { ...
/// ```

const invalid = InvalidAnnotation();

/// This annotation can only be used inside a [GeneralEntity], in front of a
/// factory parameter.
///
/// Use this annotation if you want to have a direct getter for a modddel from
/// the unvalidated [GeneralEntity].
///
/// Unlike a [SimpleEntity], the [GeneralEntity] hides its modddels inside the
/// [ValidEntity] and [InvalidEntity] union-cases, so you can only access them
/// after calling the "mapValidity" method (or other map methods).
///
/// For example :
///
/// ```dart
///   final firstName = fullName.firstName;
///   //ERROR : The getter 'firstName' isn't defined for the type 'FullName'.
///
///   final firstName = fullName.mapValidity( valid: (valid) => valid.firstName,
///       invalid: (invalid) => invalid.firstName);
///   //No error.
/// ```
///
/// That's because the GeneralEntity may have a GeneralFailure, which may be
/// unnoticed by you the developer.
///
///  Nonetheless, there are some usecases where the modddel doesn't have an
///  impact on the general validation, so it's safe to have a direct getter. For
///  example : Having a getter for an "id" field.
///
/// Example :
///
/// ```dart
/// factory FullName({
///    @withGetter required UniqueId id,
///    required Name firstName,
///    required Name lastName,
///  }) { ...
/// ```
const withGetter = WithGetterAnnotation();

/// Same as specifying both the [valid] and [withGetter] annotations.
///
/// Example :
///
/// ```dart
/// factory FullName({
///    @validWithGetter required String id,
///    required Name firstName,
///    required Name lastName,
///  }) { ...
/// ```
const validWithGetter = ValidWithGetterAnnotation();

/// Same as specifying both the [invalid] and [withGetter] annotations.
///
/// Example :
/// ```dart
/// factory FullName({
///    required Name firstName,
///    required Name lastName,
///    @invalidWithGetter @TypeName('InvalidName?') required InvalidName? middleName,
///  }) { ...
/// ```
const invalidWithGetter = InvalidWithGetterAnnotation();

/// This annotation can only be used inside a [SingleValueObject], a
/// [MultiValueObject] or a [GeneralEntity], in front of a factory parameter.
///
/// In general, use this annotation when you want the modddel to contain a
/// nullable field that, when null, should make the modddel invalid and hold a
/// failure (that you should provide as a String).
///
/// Note that :
/// - For a [SingleValueObject] or a [MultiValueObject] : The failure must be a
///   [ValueFailure]
/// - For a [GeneralEntity] : The failure must be a [GeneralFailure]
///
/// _Example :_ Using [NullFailure] inside a [GeneralEntity]
///
/// ```dart
/// class FullName extends GeneralEntity<FullNameGeneralFailure, InvalidFullName,
///     ValidFullName> with $FullName {
///   factory FullName({
///     @NullFailure('const FullNameGeneralFailure.incomplete()')
///         required Name? lastName,
///     ...
///   }) {
///     ...
///
/// ```
///
/// Here, if the field `lastName` is null, then the `FullName` entity will be an
/// `InvalidEntityGeneral`, with as a general failure
/// `FullNameGeneralFailure.incomplete()`. The field `lastName` in
/// `ValidFullName` is non-nullable.
class NullFailure {
  const NullFailure(this.failure);

  final String failure;
}

/// Use this to manually provide the type of a [SingleValueObject],
/// [MultiValueObject], [SimpleEntity] or [GeneralEntity]
/// constructor parameter.
///
/// This is useful when the type does not exist at the time of generation (which
/// is usually the case when the type class itself is generated).
///
/// Example :
///
/// ```dart
/// @modddel
/// class Person extends SimpleEntity<InvalidPersonContent, ValidPerson>
///     with $Person {
///   factory Person({
///     required Age age,
///     @TypeName('ValidName') @valid required ValidName validName,
///   }) {
///     return $Person._create(
///       age: age,
///       validName: validName,
///     );
///   }
///
///   const Person._();
/// }
/// ```
///
/// Here, `ValidName` is a generated class so it's not defined during the
/// generation. So we provided the type using `@TypeName('ValidName')`.
class TypeName {
  const TypeName(this.typeName);
  final String typeName;
}
